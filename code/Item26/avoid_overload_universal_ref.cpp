#include <boost/type_index.hpp>
#include <cstdio>
#include <string>
#include <set>
#include <chrono>

// • Overloading on universal references almost always leads to the universal refer‐
// ence overload being called more frequently than expected.
// • Perfect-forwarding constructors are especially problematic, because they’re
// typically better matches than copy constructors for non-const lvalues, and
// they can hijack derived class calls to base class copy and move constructors.

std::multiset<std::string> names; 
void logAndAdd(const std::string & name)
{
    auto now = std::chrono::system_clock::now();
    // log(now, "logAndAdd");
    names.emplace(name);
}

void test_first_version()
{
    std::string petName("Darla");
    logAndAdd(petName); // passing lvalue
    logAndAdd(std::string("Persephone")); // passing rvalue
    logAndAdd("Patty Dog"); // passing literal
}

// second version, using template and universal reference
template <typename T>
void logAndAdd(T&& name)
{
    auto now = std::chrono::system_clock::now();
    // log(now, "logAndAdd");
    names.emplace(std::forward<T>(name));
}

void test_second_version()
{
    std::string petName = "Darla";
    logAndAdd(petName); // passing lvalue, same as above
    logAndAdd(std::string("Persephone")); // passing rvalue, forwading rvalue to emplace
    logAndAdd("Patty Dog"); // passing literal, forwarding literal to emplace
}

// problem: we need a logAndAdd(int idx) function.
// let's check out what would happen.

std::string nameFromIdx(int idx)
{
    return "name" + std::to_string(idx);
}

void logAndAdd(int idx)
{
    auto now = std::chrono::system_clock::now();
    // log(now, "logAndAdd");
    names.emplace(nameFromIdx(idx));
}

void test_third_version()
{
    std::string petName = "Darla";

    logAndAdd(petName); // passing lvalue, same as above
    logAndAdd(std::string("Persephone")); // passing rvalue, forwading rvalue to emplace
    logAndAdd("Patty Dog"); // passing literal, forwarding literal to emplace

    logAndAdd(22);  // passing int, but it will be forwarded to emplace, then to nameFromIdx
    
    // uncomment to see the compile error
    // short nameIdx = 22;
    // logAndAdd(nameIdx); // passing short, but it will be forwarded to emplace, then forwarded std::string constructor.
    // short && type overloading is a better match than int, so it will be called.
}


class Person 
{
public:
    template <typename T>
    explicit Person(T&& n) : name_(std::forward<T>(n)) {}

    explicit Person(int idx): name_(nameFromIdx(idx)) {}

    Person(const Person& rhs) = default;
    Person(Person&& rhs) = default;


private:
    std::string name_;
};

void test_person_version_1()
{   
    Person p("Nancy"); // call Person(T&& n)
    // auto cloneOfP(p); // calls template: Person(Person& rhs) compiler error!

    const Person cp("Nancy"); // call Person(T&& n)
    auto cloneOfCp(cp); // copy constructor, generated by compiler

}

// class SpecialPerson: public Person
// {
// public:
//     SpecialPerson(const std::string& name) : Person("Special" + name)
//     {

//     }

//     SpecialPerson(const SpecialPerson& rhs) : Person(rhs) // calls base's forward constructor
//     {
//         // do something
//     }
    
//     SpecialPerson(SpecialPerson&& rhs) : Person(std::move(rhs)) // calls base's forward constructor
//     {
//         // do something
//     }

// };


void test_special_person()
{
    // SpecialPerson sp("Nancy");

    // uncomment to see the compile error
    // SpecialPerson sp2(sp); // calls SpecialPerson(const SpecialPerson& rhs)
    // SpecialPerson sp3(std::move(sp)); // calls SpecialPerson(SpecialPerson&& rhs)

}

int main()
{
    test_first_version();
    test_second_version();
    test_third_version();
    test_person_version_1();
    test_special_person();

    return 0;
}